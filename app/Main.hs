{--
 - For determining a monthly breakdown of spending by category
 - given a csv file with the following format
 - 1) date
 - 2) transaction type
 - 3) description
 - 4) amount
 - 5) category
 - 6) note
 -
 - C.Phang 21/01/17--}

{-# LANGUAGE DeriveGeneric #-}
module Main where

import qualified Data.ByteString.Lazy.Char8 as C
import Data.List.Split
import Data.List
import Data.Either
import Data.Csv
import qualified Data.Vector as V
import qualified Data.Map as Map

import GHC.Generics

import Text.PrettyPrint.ANSI.Leijen hiding ((<$>))
import Text.Printf
import qualified Options.Applicative as Op

-- | a datatype representing a transaction made
-- For importing from csv
data Transaction = Transaction  { date :: String,
                                  transaction_type  :: String,
                                  description :: String,
                                  amount :: Float,
                                  category :: String,
                                  note :: String
                                } deriving (Show, Generic)
instance FromRecord Transaction
instance ToRecord Transaction

-- | a datatype representing categories and the amount spent on each
-- For exporting to csv
data Category = Category { cat_type :: String,
                           total :: Float
                         } deriving (Generic)
instance FromRecord Category
instance ToRecord Category

{--------------------------------------------------------------------
 - Cmdline option processing 
 -------------------------------------------------------------------- --}

data CmdInput = CmdInput { input :: String,
                           output :: Maybe String
                         }

-- | Parsing of the command line input.
-- Input file is mandatory, output files are not
sample = CmdInput
    <$> Op.strOption
        ( Op.long "input"
        Op.<> Op.short 'i'
        Op.<> Op.metavar "FILE.csv"
        Op.<> Op.help "input file")
    <*> Op.optional (Op.strOption
        ( Op.long "output"
          Op.<> Op.short 'o'
          Op.<> Op.metavar "FILE.csv"
          Op.<> Op.help "output file"))

-- | Parsed output generated upon --help option being triggered
opts = Op.info (Op.helper <*> sample)
  ( Op.fullDesc
  Op.<> Op.progDesc "Outputs a breakdown of monthly spending by category"
  Op.<> Op.header "A breakdown of monthly spending by category given a csv file")


genRawInput fname = do
  f <- readFile fname
  return $ splitOn "\n" f
  
{--------------------------------------------------------------------
 - Pure computation
 -------------------------------------------------------------------- --}

-- | Gives the amount spent on each category in an array of Acc_Record.
-- Converts an array of Acc_record to a Map of (categories, amounts),
-- with duplicate amounts summed.
calculate_categories input = Map.assocs
                              $ Map.filter (/=0)
                              $ Map.fromListWith (+) records
    where records = [(category r, amount r) | x <- get_records input,
                                              let r = V.head x,
                                              V.length x /= 0]
          get_records input = rights $ process <$> input

-- | Converts a csv String to a Vector containing an Acc_Record datatype (Right)
-- or an error message indicating a failed parse (Left)
process :: String -> Either String (V.Vector Transaction)
process input = decode NoHeader bs
  where bs = C.pack input

{--------------------------------------------------------------------
 - Output processing (to stdout or csv)
 -------------------------------------------------------------------- --}

-- | Generates formatted output to IO () from a list of [(k,v)]
-- Creates headers for columns and renders amounts in colours depending on
-- whether they're negative (red) or positive (green)
gen_output :: [(String,Float)] -> IO ()
gen_output asclist = putDoc $ header <> (vcat . lines) asclist <> linebreak
    where header = fill 25 ((bold . text) "Category")
                    <+> ((bold . text) "Amount(Â£)")
                    <> linebreak
          lines asclist = map getLine asclist
          getLine (k,v) = fill 25 (text k) <+> (renderVal v)
          renderVal v = if v <= 0
                          then red (text $ format v)
                          else green (text $ format v)
          format v = printf "%.2f" $ v :: String

-- | Takes a [(String,Float)] generated by calculate_categories
-- and outputs it to a csv file using the specified FilePath.
exportToCsv :: [(String,Float)] -> FilePath -> IO()
exportToCsv asclist fp = C.writeFile fp process_out
  where process_out = encode (convertToCat <$> asclist)
        convertToCat ((c,t)) = Category c t

main :: IO ()
main = Op.execParser opts >>= run

run :: CmdInput -> IO()
run (CmdInput fname Nothing) = do
  i <- genRawInput fname
  gen_output $ calculate_categories i 
run (CmdInput i_fname (Just o_fname)) = do
  i <- genRawInput i_fname
  let output = calculate_categories i
  exportToCsv output o_fname

